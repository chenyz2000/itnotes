[TOC]

# 任务管理

直接执行一个命令即在前台运行一个任务：

```shell
ping z.cn
```

在命令后方添加`&`（`&`前有空格）可将任务挂到后台运行：

```shell
ping -c 99 z.cn &
#可以将输出信息定向到指定文件，避免输出信息在终端干扰后续操作
ping -c 99 z.cn > ping.log &

#将整个for循环/while循环放入后台 在done后面添加&
for i in {1..10}
do
sleep 1
echo $i
done &
echo '---'
```

使用`jobs`命令可以查看当前终端的任务列表，常用选项：

-  `-l`	在正常信息基础上列出进程号
-  `-n`	仅列出上次通告之后改变了状态的进程
-  `-p`	仅列出进程号
-  `-r`	限制仅输出运行中的任务
-  `-s`	限制仅输出停止的任务



对于一个正在执行的前台任务，可使用以下命令管理：

- <kbd>ctrl</kbd> <kbd>z</kbd>  挂起(suspend)进程，即将一个正在前台执行的命令放到后台，并且暂停。使用`fg`或`bg`可以继续执行。

- <kbd>ctrl</kbd> <kbd>c</kbd>  终止正在前台执行的命令。




- `fg`  将后台运行的进程任务放到前台运行

  如果后台中有多个命令，可以用 `fg %后台任务编号`调用指定编号的任务。

  使用`jobs`查看列表可获取任务编号。

  ```shell
  fg  #将最新的后台任务提到前台执行
  fg %2  #将2号后台任务提到前台执行
  ```

- `bg`  将任务放置到后台执行，如果任务是暂停状态，也会被启动起来。

  用法同`fg`

# 保持后台运行

## 后台任务退出的原因

仅使用`&`将任务放入后台，并不能保证任务一直在后台运行，如果断开该任务的终端会话，该任务将会因为SIGHUP信号而退出（任务中断执行），其流程如下：

> 1. 用户准备退出 session
> 2. 系统向该 session 发出`SIGHUP`信号
> 3. session 将`SIGHUP`信号发给所有子进程
> 4. 子进程收到`SIGHUP`信号后，自动退出

欲在退出会话（自动断开话主动登出）后，仍让任务在后台运行可以使用以下解决思路：

- 让进程忽略 HUP 信号
- 让进程运行在新的会话里从而成为不属于该终端（执行命令的终端）的子进程

## 任务后台运行的方法

- `&`后台进程脱离当前shell

  `&`后台运行的进程为当前shell的子进程，如果当前shell进程被直接杀死——接收到`SIGHUP`信号（除了直接kill进程外，在图形界面中直接关闭终端模拟器程序以及网络中断也会收到该信号），后台子进程将因为父进程退出而退出。

  如果在**提交`&`后台命令后**，**使用exit（或<kbd>ctrl</kbd> <kbd>d</kbd> ）退出当前终端**，该后台进程就会脱离当前shell的父进程将变成进程号为`1`的进程的子进程，从而**进程保持运行**。

  ```shell
  ping z.cn > ping.log &
  ```
  
- `nohup`

  让进程与父Shell完全脱离，并**忽略HUP信号**。

  默认会将标准输出写入名为`nohup.out`的文件，也可以自行指定输出信息的写入文件。

  ```shell
  nohup ping -c 99 z.cn &>ping.log &
  ```
  
- 子shell`()`+`&`

  将一个或多个命名包含在`()`中就能让这些命令在**子 shell 中运行**，将命令连同`&`也放入`()`内之后，该命令就**不再是当前终端进程的子进程**。

  ```shell
  (ping z.cn -c 100 &> /tmp/log &)
  ```

- `setsid`

  让提交的命令分配的进程不成为当前终端的子进程。因此退出终端后，提交的命令不会收到HUP信号。

  ```shell
  setid ping -c 10 &> ping.log
  ```
  
- `disown`

  如果想要命令后台运行，但是未加以上任何后台处理方式就已经提交了命令，可以使用作业管理和`disown`解决该问题。

  - 如果提交命令时已经用“&”将命令放入后台运行，直接使用`disown`即可。

    1. `jobs`命令查看该后台任务的作业号(jobID)
  2. `disown -h %<jobID>`
  
  - 如果提交命令时未经用“&”将命令放入后台运行，可以先挂起任务，而后`bg`放入后台，最后再使用`disown`

    1. <kbd>Ctrl</kbd> <kbd>z</kbd>挂起任务
  2. `jobs`命令查看挂起的作业号(jobID)
    3. `bg`放入后台执行
    4. `disown -h %<jobID>`
  
    ```shell
  ping z.cn > ping.log
    #ctrl z挂起
    jobs
    bg #作业不止一个时 要使用 bg %作业号
    disown -h %1
    ```
  
  disown选项：

  - `-a`	如果不提供 JOBSPEC 参数，则删除所有任务。
  
- `-h`	标识每个 JOBSPEC 任务，从而当 shell 接收到 SIGHUP信号时不发送 SIGHUP 给指定任务。
  
  - `-r`	仅删除运行中的任务。
  
- `tmux`、`screen`等工具

  用于大量运行后台任务的场景，功能强大。

- 此外，对于要时刻在后台运行的进程，尤其是希望其在系统启动后总是自行后台运行，可使用systemd或crontab。

# 多后台任务控制

模拟多线程，Shell中没有真正意义的多线程，可启动多个后端进程，最大程度利用cpu性能。

## wait 进程阻塞--等待后台任务完成

需要等待后台任务完成后再执行后续任务的场景。

`wait`等待作业号或者进程号制定的进程退出，返回最后一个作业或进程的退出状态状态。

如果没有指定参数，则等待所有子进程的退出，其退出状态为0。

shell中等待使用wait，不会等待**调用函数中的子任务**；在函数中使用wait，则只等待函数中启动的后台子任务。（类似其他编程语言的多线程编程）

示例：

```shell
for f in $(ls -a)
do
{
  chmod 755 $f
  cp $f /tmp/ -av
}& #将放入后台 相当有新开一个线程
done
wait  #等待以上所有任务（放入后台的任务）执行完毕后才会执行下面的命令
echo "done at $(date)" >> /tmp/copy.log
```

## 并发任务数量控制

为了避免后台任务过多（操作系统压力过大）而需要控制后台任务数量的场景。

### xargs控制

xarags选项：

- `-P <N>`  指定运行后面命令的进程数量（默认为1），0时表示尽可能地大；

- `-n 1`   指定每次使用的传入参数（管道符传来的参数）的数量，默认是所有参数。

  控制并发任务数量的场景下应该将其设置为1。

  ```shell
  echo {1..3}|xargs #打印1 2 3到一行 一次使用了所有传入参数
  echo {1..3}|xargs -n 1 #打印3行，分别是1,2,3，一次使用1个参数
  ```

- `-I {}`  指定将xargs会将传入参数赋予某个名称，一般约定习惯命名为`{}`，其他命令可直接使用`{}`（可任意起名）

  ```shell
  echo {1..3}|xargs -n 1 -I {} echo "get arg {}"
  ```

  

```shell
thread_num=5
all_num=100

seq 1 ${all_num} | xargs -n 1 -I {} -P ${thread_num} sh -c "echo dosomething;sleep 1;echo -----"

wait
echo -e "end"
```



### fifo有名管道控制

```shell
fifofile="/tmp/$$.fifo"  #$$为当前shell的pid
mkfifo $fifofile
exec {fdnum}<>$fifofile #让系统分配一个fd索引值
#exec 6<>$fifofile  #也可以为fifofile的文件手动指定一个描述符6
thread_num=5

for ((i=0;i<${thread_num};i++));do  #为进程创建相应的占位
    echo  #为进程创建相应的占位
done >&$fdnum  #将占位信息写入管道$fdnum

for j in {1..50}
do
#每次执行read -u$fdnum命令，将从FD6中减去一个换行符号\n，然后向下执行
#当$fdnum中没有回车符，就停止，从而实现线程数量控制
read -u$fdnum
{
  sleep 1  #换成要执行的代码，这里模拟假设普通顺序执行时 每一条代码执行要花费1s
  echo "$j...pid is $$"
  echo >&$fdnum  #当任务执行完后，会释放管道占位，所以补充一个占位
}& #将进程放入后台
done

wait
echo "done at $(date)" >> /tmp/copy.log
# exec $fdnum>&-  #关闭标识符
```

有名管道和无名管道：

- 无名管道`|`：`ps aux | grep ping`

- 有名管道：`mkfifo /tmp/fd1`  由`mkfifo`创建（fifo first input first output），如果管道内容为空，则阻塞。示例：

  1. 打开一个终端，输入执行：

     ```shell
     mkfifo /tmp/fd1; cat /tmp/fd1; echo "oooh, done!"
     ```

     将发现echo 内容没有输出，当前shell处于阻塞状态，因为没向/tmp/fd1写入过内容

  2. 新开一个终端，输入执行：

     ```shell
     echo "unlock" >> /tmp/fd1 #随便输入什么内容都行
     ```

     发现前一个终端阻塞解除，执行了后面echo的内容。

文件描述符(file descriptor)：

> linux为了实现一切皆文件的设计哲学，不仅将数据抽象成了文件，也将一切操作和资源抽象成了文件，比如说硬件设备，socket，磁盘，进程，线程等。

内核（kernel）利用文件描述符（file descriptor）来访问文件，每打开或创建一个文件，内核就会向进程返回一个fd，fd是一个非负的整数。

习惯上，

- 标准输入（standard input）的文件描述符是 0
- 标准输出（standard output）是 1
- 标准错误（standard error）是 2

3以后对应打开的文件，使用`ulimit -n`可查看一个进程可打开的文件描述符数量。

# 附

## 进程、线程、服务和任务

- 进程（process）：**运行中的应用程序**，每一个进程都有自己独立的内存空间。

  一个应用程序可以同时启动多个进程。

- 线程（thread）：**操作系统能够进行运算的最小单位**。

  线程被包含在进程之中，是进程中的实际运行单位。一条线程是指进程中的一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。同一进程中的所有线程在同一块地址空间中工作。

- 服务（service）即守护进程：一直运行在系统后台的进程。

- 任务（task）：一个很宽泛的概念，由软件完成的一个活动，为达到某一目的而进行的一系列的操作，一般由很多个进程相互作用完成。

## 进程类型

- 交互进程：是由一个Shell启动的进程。可以在前台运行，也可以在后台运行。
- 批处理进程：和终端没有联系，是一个进程序列。
- 监控进程（系统守护进程）：Linux系统启动时运行的进程，常驻于后台。

## 进程组与会话

- 进程组(process group)：一个或多个进程的集合。

  每个进程组称为一个工作(job)。

  进程组有一个组长进程，组长进程ID为进程组ID，该组的其余进程为组长进程的子进程，组长进程即为其他子进程的父进程。

  只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。

  进程组生存期: 进程组创建到最后一个进程离开(终止或转移到另一个进程组)

- 会话(session)：一个或多个进程组的集合。

  会话是由其中的进程建立，该进程为会话的领导进程(session leader)。

  会话领导进程的PID成为识别会话的SID(session ID)。

